# –ò–º–ø–æ—Ä—Ç —Ñ—Ä–µ–π–º–≤–æ—Ä–∫–æ–≤
import asyncio
import requests
import datetime, zoneinfo
import math
from aiogram import Bot, Dispatcher, types
from aiogram.filters import Command
from aiogram import F
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.filters import Command
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ç–æ–∫–µ–Ω–∞ –±–æ—Ç–∞ –∏ –æ–±—ä–µ–∫—Ç–æ–≤ –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∞ –∏ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞ —Å–æ—Å—Ç–æ—è–Ω–∏–π
API_TOKEN = 'TOKEN'
bot = Bot(token=API_TOKEN)
storage = MemoryStorage()
dp = Dispatcher()

# –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏–π, –∫–ª–∞–≤–∏–∞—Ç—É—Ä –∏ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
forecast_message = ""
weather_message = ""
keyboard = None
user_reminders = {}
user_languages = {}
user_reminder_times = {}
user_states = {}

# –°–ª–æ–≤–∞—Ä—å —Å–æ –≤—Å–µ–º–∏ —Å–æ–æ–±—â–µ–Ω–∏—è–º–∏ Telegram –±–æ—Ç–∞ –Ω–∞ —Ä—É—Å—Å–∫–æ–º –∏ –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–æ–º —è–∑—ã–∫–∞—Ö
translations = {
    'start': {
        'ru': "–î–∞–Ω–Ω—ã–π –±–æ—Ç –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –ø–æ–≥–æ–¥—É. –£–∫–∞–∂–∏ –≥–æ—Ä–æ–¥",
        'en': "This bot shows the weather. Please specify the city"
    },
    'settings_question': {
        'ru': "–ù–∞ –∫–∞–∫–æ–µ –≤—Ä–µ–º—è –≤—ã—Å—Ç–∞–≤–∏—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ –æ –ø–æ–≥–æ–¥–µ –≤ —Ñ–æ—Ä–º–∞—Ç–µ xx:xx?",
        'en': "What time would you like to set the weather reminder in the format hh:mm?"
    },
    'city_check': {
        'ru': "–ü—Ä–æ–≤–µ—Ä—å –Ω–∞–∑–≤–∞–Ω–∏–µ –≥–æ—Ä–æ–¥–∞",
        'en': "Check the city name"
    },
    'data_error': {
        'ru': "–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö –æ –ø–æ–≥–æ–¥–µ",
        'en': "Error while fetching weather data"
    },
    'reminder_set': {
        'ru': "–¢–µ–ø–µ—Ä—å —Å–æ–æ–±—â–µ–Ω–∏–µ –±—É–¥–µ—Ç –ø—Ä–∏—Ö–æ–¥–∏—Ç—å –∫–∞–∂–¥—ã–π –¥–µ–Ω—å –≤ {time}",
        'en': "Now the message will come every day at {time}"
    },
    'weather_interest': {
        'ru': "–ò–Ω—Ç–µ—Ä–µ—Å—É–µ—Ç –ª–∏ –≤–∞—Å –ø–æ–≥–æ–¥–∞?",
        'en': "Are you interested in the weather?"
    },
    'word': {
        'ru': "–î–∞",
        'en': "Yes"
    },
    'invalid_time_format': {
        'ru': "–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –≤—Ä–µ–º–µ–Ω–∏. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ñ–æ—Ä–º–∞—Ç hh:mm.",
        'en': "Invalid time format. Please use hh:mm format."
    }
}

# –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏–π –¥–ª—è FSM (–º–∞—à–∏–Ω—ã —Å–æ—Å—Ç–æ—è–Ω–∏–π)
class EchoStates(StatesGroup):
    waiting_for_confirmation = State()
    waiting_for_message = State()
# –ó–∞–ø—É—Å–∫ Telegram –±–æ—Ç–∞
@dp.message(Command('start'))
async def first_message(message: types.Message):
    language = user_languages.get(message.from_user.id, 'ru')
    await message.reply(translations['start'][language])
# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π
@dp.message(Command('settings'))
async def start_command(message: types.Message):
    language = user_languages.get(message.from_user.id, 'ru')
    user_states[message.from_user.id] = EchoStates.waiting_for_message
    await message.answer(translations['settings_question'][language])
# –ê–Ω–≥–ª–∏–π—Å–∫–∏–π —è–∑—ã–∫
@dp.message(Command('en'))
async def set_language_en(message: types.Message):
    user_id = message.from_user.id
    user_languages[user_id] = 'en'
    await message.reply("You choose English language.")
# –†—É—Å—Å–∫–∏–π —è–∑—ã–∫
@dp.message(Command('ru'))
async def set_language_ru(message: types.Message):
    user_id = message.from_user.id
    user_languages[user_id] = 'ru'
    await message.reply("–¢—ã –≤—ã–±—Ä–∞–ª —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫")
# –§—É–Ω–∫—Ü–∏—è set_reminder_time, –Ω—É–∂–Ω–∞—è –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è —Å –≤—Ä–µ–º–µ–Ω–µ–º –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è
@dp.message(lambda message: user_states.get(message.from_user.id) == EchoStates.waiting_for_message)
async def set_reminder_time(message: types.Message):
    user_id = message.from_user.id
    language = user_languages.get(user_id, 'ru')
    time_input = message.text.strip()
    
    try:
        hour, minute = map(int, time_input.split(':'))
        if not (0 <= hour < 24 and 0 <= minute < 60):
            raise ValueError
        user_reminder_times[user_id] = time_input
        await message.reply(translations['reminder_set'][language].format(time=time_input))
        asyncio.create_task(send_daily_reminder(user_id, hour, minute))
        del user_states[user_id]
        
    except ValueError:
        await message.reply(translations['invalid_time_format'][language])

async def send_daily_reminder(user_id, hour, minute):
    while True:
        now = datetime.datetime.now()
        target_time = now.replace(hour=hour, minute=minute, second=0, microsecond=0)
        if now > target_time:
            target_time += datetime.timedelta(days=1)
        wait_time = (target_time - now).total_seconds()
        await asyncio.sleep(wait_time)
        language = user_languages.get(user_id, 'ru')
        await bot.send_message(user_id, translations['weather_interest'][language])

@dp.message(F.text)
async def weather(message: types.Message):
    global weather_message, keyboard, forecast_message
    city = message.text
    user_id = message.from_user.id
    language = user_languages.get(user_id, 'ru')
    try:
        response = requests.get(f"http://api.openweathermap.org/data/2.5/weather?q={city}&lang=ru&units=metric&appid=API")
        data = response.json()
        if response.status_code != 200:
            await message.reply(translations['city_check'][language])
            return
    except Exception as e:
        await message.reply(translations['data_error'][language])
        return

    code_ru_en = {
        "Clear": ("–Ø—Å–Ω–æ ‚òÄÔ∏è", "Clear ‚òÄÔ∏è"),
        "Clouds": ("–û–±–ª–∞—á–Ω–æ ‚òÅÔ∏è", "Cloudy ‚òÅÔ∏è"),
        "Rain": ("–î–æ–∂–¥—å üåßÔ∏è", "Rain üåßÔ∏è"),
        "Drizzle": ("–î–æ–∂–¥—å üå¶Ô∏è", "Drizzle üå¶Ô∏è"),
        "Thunderstorm": ("–ì—Ä–æ–∑–∞ ‚õàÔ∏è", "Thunderstorm ‚õàÔ∏è"),
        "Snow": ("–°–Ω–µ–≥ ‚ùÑÔ∏è", "Snow ‚ùÑÔ∏è"),
        "Mist": ("–¢—É–º–∞–Ω üå´Ô∏è", "Mist üå´Ô∏è")
    }
    lat = data['coord']['lat']
    lon = data['coord']['lon']
    timezone_offset = data.get('timezone', 0)
    def get_local_time(timestamp, offset_seconds):
        # –ü–æ–ª—É—á–∞–µ–º –≤—Ä–µ–º—è –≤ UTC —Å timezone-aware –æ–±—ä–µ–∫—Ç–æ–º
        utc_time = datetime.datetime.fromtimestamp(timestamp, tz=datetime.timezone.utc)
        # –î–æ–±–∞–≤–ª—è–µ–º —Å–º–µ—â–µ–Ω–∏–µ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏
        local_time = utc_time + datetime.timedelta(seconds=offset_seconds)
        return local_time
    weather_message = f"–ü—Ä–æ–≥–Ω–æ–∑ –ø–æ–≥–æ–¥—ã –≤ –≥–æ—Ä–æ–¥–µ: {city}\n" if language == 'ru' else f"Weather forecast in the city: {city}\n"
    weather = data
    temp = weather["main"]["temp"]
    temp1 = weather["main"]["feels_like"]
    humidity = weather["main"]["humidity"]
    pressure = weather["main"]["pressure"]
    wind = weather["wind"]["speed"]
    sunrise_utc = data["sys"]["sunrise"]
    sunset_utc = data["sys"]["sunset"]
    sunrise_local = get_local_time(sunrise_utc, timezone_offset)
    sunset_local = get_local_time(sunset_utc, timezone_offset)
    now_utc = datetime.datetime.now(tz=datetime.timezone.utc)
    now_local = now_utc + datetime.timedelta(seconds=timezone_offset)
    length = sunset_local - sunrise_local
    weather_main = weather["weather"][0]["main"]
    wd_ru, wd_en = code_ru_en.get(weather_main, ("–ù–µ –ø–æ–Ω—è—Ç–Ω–æ, –∫–∞–∫–∞—è –ø–æ–≥–æ–¥–∞", "Weather unclear"))
    if language == 'ru':
        weather_message += (
        f"{now_local.strftime('%Y-%m-%d %H:%M')} \n"
        f"–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞: {temp}¬∞C {wd_ru}\n"
        f"–û—â—É—â–∞–µ—Ç—Å—è –∫–∞–∫: {temp1}¬∞C \n"
        f"–í–ª–∞–∂–Ω–æ—Å—Ç—å: {humidity}%\n"
        f"–î–∞–≤–ª–µ–Ω–∏–µ: {math.ceil(pressure / 1.333)} –º–º.—Ä—Ç.—Å—Ç\n"
        f"–í–µ—Ç–µ—Ä: {wind} –º/—Å \n"
        f"–í–æ—Å—Ö–æ–¥ —Å–æ–ª–Ω—Ü–∞: {sunrise_local.strftime('%Y-%m-%d %H:%M:%S')}\n"
        f"–ó–∞–∫–∞—Ç —Å–æ–ª–Ω—Ü–∞: {sunset_local.strftime('%Y-%m-%d %H:%M:%S')}\n"
        f"–ü—Ä–æ–¥–æ–ª–∂–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –¥–Ω—è: {length}"
    )
    else:
        weather_message += (
        f"{now_local.strftime('%Y-%m-%d %H:%M')} \n"
        f"Temperature: {temp}¬∞C {wd_en}\n"
        f"Feels like: {temp1}¬∞C \n"
        f"Humidity: {humidity}%\n"
        f"Pressure: {math.ceil(pressure / 1.333)} mmHg\n"
        f"Wind: {wind} m/s \n"
        f"Sunrise: {sunrise_local.strftime('%Y-%m-%d %H:%M:%S')}\n"
        f"Sunset: {sunset_local.strftime('%Y-%m-%d %H:%M:%S')}\n"
        f"Length of day: {length}"
    )
    response = requests.get(f"http://api.openweathermap.org/data/2.5/forecast?q={city}&lang=ru&units=metric&appid=API")
    data = response.json()
# –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–π –¥–µ–Ω—å
    today = datetime.datetime.now().date()
    dates_of_interest = [today + datetime.timedelta(days=i) for i in range(3)]
# –í—Ä–µ–º—è, –∫–æ—Ç–æ—Ä–æ–µ –Ω–∞—Å –∏–Ω—Ç–µ—Ä–µ—Å—É–µ—Ç (—á–∞—Å—ã)
    target_hours = [1, 7, 13, 19]
    time_periods = {
    1: '–ù–æ—á—å',
    7: '–£—Ç—Ä–æ',
    13: '–ü–æ–ª–¥–µ–Ω—å',
    19: '–í–µ—á–µ—Ä'
    }
    forecast_message = f"–ü—Ä–æ–≥–Ω–æ–∑ –ø–æ–≥–æ–¥—ã –≤ –≥–æ—Ä–æ–¥–µ: {city}" if language == 'ru' else f"Weather forecast in the city: {city}"

    grouped_forecasts = {}

    for forecast in data['list']:
        date_time = datetime.datetime.fromtimestamp(forecast["dt"])
        forecast_date = date_time.date()
        if forecast_date in dates_of_interest and date_time.hour in target_hours:
            if forecast_date not in grouped_forecasts:
                grouped_forecasts[forecast_date] = []
            grouped_forecasts[forecast_date].append(forecast)

    # –¢–µ–ø–µ—Ä—å –≤—ã–≤–æ–¥–∏–º –ø–æ –¥–∞—Ç–∞–º
    for date_key in sorted(grouped_forecasts.keys()):
        # –í—ã–≤–æ–¥–∏–º –¥–∞—Ç—É
        if language == 'ru':
            forecast_message += f"\n{date_key.strftime('%Y-%m-%d')}\n"
        else:
            forecast_message += f"\n{date_key.strftime('%Y-%m-%d')}\n"

        # –î–ª—è –∫–∞–∂–¥–æ–≥–æ –ø—Ä–æ–≥–Ω–æ–∑–∞ –≤ —ç—Ç–æ—Ç –¥–µ–Ω—å, —Å–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –≤—Ä–µ–º–µ–Ω–∏
        for fc in sorted(grouped_forecasts[date_key], key=lambda x: x['dt']):
            dt_obj = datetime.datetime.fromtimestamp(fc["dt"])
            hour = dt_obj.hour
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–∞–∑–≤–∞–Ω–∏–µ –ø–µ—Ä–∏–æ–¥–∞ –≤—Ä–µ–º–µ–Ω–∏
            period_name = time_periods.get(hour, dt_obj.strftime('%H:%M'))

            temp = fc["main"]["temp"]
            temp1 = fc["main"]["feels_like"]
            humidity = fc["main"]["humidity"]
            pressure = fc["main"]["pressure"]
            wind_speed = fc["wind"]["speed"]
            weather_main = fc["weather"][0]["main"]
            wd_ru, wd_en = code_ru_en.get(weather_main, ("–ù–µ –ø–æ–Ω—è—Ç–Ω–æ, –∫–∞–∫–∞—è –ø–æ–≥–æ–¥–∞", "Weather unclear"))

            if language == 'ru':
                forecast_message += (
                    f"{period_name}: –¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞: {temp:.2f}¬∞C {wd_ru}\n"
                    f"–û—â—É—â–∞–µ—Ç—Å—è –∫–∞–∫: {temp1:.2f}¬∞C \n"
                )
            else:
                forecast_message += (
                    f"{period_name}: Temperature: {temp:.2f}¬∞C {wd_en}\n"
                    f"Feels like: {temp1:.2f}¬∞C \n"
                )
    button_1 = types.InlineKeyboardButton(text="–ü–æ–≥–æ–¥–∞ –Ω–∞ 3 –¥–Ω—è", callback_data="button_1")
    keyboard = types.InlineKeyboardMarkup(inline_keyboard=[[button_1]])
    await message.reply(weather_message, reply_markup=keyboard)

@dp.callback_query(F.data == "button_1")
async def handle_button_click(callback_query: types.CallbackQuery):
    user_id = callback_query.from_user.id
    language = user_languages.get(user_id, 'ru')
    await bot.send_message(user_id, forecast_message)
    await callback_query.answer()
async def main():
   await dp.start_polling(bot)
if __name__ == '__main__':
   asyncio.run(main())